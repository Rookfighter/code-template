#!/usr/bin/python3

'''
codetempl.py

Created on: 28 Apr 2017
    Author: Fabian Meyer
'''

import sys
import re
import argparse
import getpass
import datetime
import subprocess
import json
import os.path

VERSION = '0.1.0'
HOME_DIR = os.path.expanduser("~")
ESC_MAP = {
    '$': r'\$'
}
VAR_USER = {}


def get_process_output(args, cwd=None):
    proc = subprocess.Popen(args,
        stdout=subprocess.PIPE, cwd=cwd)

    return proc.stdout.read().decode('ascii')


def get_date(cfg, filepath, param):
    fmt = '%d %b %Y' if 'fmt' not in param else param['fmt']
    now = datetime.datetime.now()
    return now.strftime(fmt)


def get_user(cfg, filepath, param):
    return getpass.getuser()


def get_gituser(cfg, filepath, param):
    path = os.path.dirname(filepath)
    return get_process_output(['git', 'config', 'user.name'], path).strip()


def get_gitemail(cfg, filepath, param):
    path = os.path.dirname(filepath)
    return get_process_output(['git', 'config', 'user.email'], path).strip()


def get_filename(cfg, filepath, param):
    return os.path.basename(filepath)


def get_filepath(cfg, filepath, param):
    return filepath


def get_guard(cfg, filepath, param):
    lvl = 0 if 'lvl' not in param else param['lvl']
    name = os.path.basename(filepath)
    name, ext = os.path.splitext(name)
    ext = ext.replace('.', '')

    regexalphanum = re.compile('[^\w]+')

    basedir = os.path.dirname(filepath)
    result = ['', ext, name]
    for i in range(lvl):
        basedir, subdir = os.path.split(basedir)
        subdir = regexalphanum.sub('', subdir)
        result.append(subdir)

    # reverse list and concatenate elements
    result.reverse()
    result = '_'.join(result).upper()
    return result


VAR_FUNCS = {
    'date': get_date,
    'user': get_user,
    'gituser': get_gituser,
    'gitemail': get_gitemail,
    'filename': get_filename,
    'filepath': get_filepath,
    'guard': get_guard
}


def map_by_colon(arglist):
    result = {}

    for arg in arglist:
        splits = arg.split(":")
        if len(splits) != 2:
            print('Error: invalid mapping {}'.format(arg))
            sys.exit(1)

        result[splits[0]] = splits[1]

    return result


def opts_from_file(filename):
    result = []
    with open(filename) as f:
        linenr = 0
        for line in f.readlines():
            linenr += 1

            line = line.strip()
            # check if line is empty or is a comment
            if len(line) == 0 or line[0] == '#':
                continue

            opts = [line]
            # find separating space
            idx = line.find(' ')
            if idx > 0:
                opts = [line[:idx].strip(), line[idx:].strip()]

            if opts[0][0] != '-':
                if len(opts[0]) == 1:
                    opts[0] = '-' + opts[0]
                else:
                    opts[0] = '--' + opts[0]

            result.extend(opts)

    return result


def parse_arguments():
    global_cfg = os.path.join(HOME_DIR, '.codetemplrc')

    parser = argparse.ArgumentParser(prog='codetempl',
        description='Generate code files from templates.')
    parser.add_argument('files', nargs='+',
        help='files to create')
    parser.add_argument('--config', help='read configuration from file')
    parser.add_argument('-v', '--version', help='shows version number',
        action='version',
        version=('codetempl Version ' + VERSION))
    parser.add_argument('--esc-char',
        dest='esc',
        help='escape character for template variables',
        default='$')
    parser.add_argument('--map-ext',
        dest='map_ext',
        help='map file extension to template files',
        action='append',
        default=[])
    parser.add_argument('--search-dir',
        dest='search_dir',
        help='search directories for template files',
        action='append',
        default=[])
    parser.add_argument('--user-var',
        dest='user_var',
        help='user defined variables',
        action='append',
        default=[])
    parser.add_argument('-f', '--force',
        dest='force',
        help='force overwrite of files',
        action='store_true')

    cfg = parser.parse_args()

    # args that will be used for the final parsing
    myargs = sys.argv[1:]
    # check if there was a config file specified
    if cfg.config is not None:
        myargs = opts_from_file(cfg.config) + myargs
    # check if there is a global config file
    if os.path.exists(global_cfg):
        myargs = opts_from_file(global_cfg) + myargs

    # parse arguments
    cfg = parser.parse_args(myargs)

    # parse the file extension mapping
    cfg.map_ext = map_by_colon(cfg.map_ext)

    # parse user defined variables
    global VAR_USER
    tmp = map_by_colon(cfg.user_var)
    for k, v in tmp.items():
        VAR_USER[k.lower()] = v

    return cfg


def get_esc(cfg):
    if cfg.esc in ESC_MAP:
        return ESC_MAP[cfg.esc]
    else:
        return cfg.esc


def replace_vars(content, cfg, filepath):
    # regex for alphanumeric identfiers starting with esc character
    regexvar = re.compile(r'{}(\w+)'.format(get_esc(cfg)))
    regexparam = re.compile(r'(\{[^\v\}]*\})')
    result = content

    # start matching all variables
    m = regexvar.search(result)
    while m is not None:
        var = m.group(1)
        varlow = var.lower()

        val = ''

        start = m.start()
        end = m.end()
        # check if we have a function for the variable
        if varlow in VAR_FUNCS:
            param = {}
            if result[m.end()] == '{':
                m2 = regexparam.search(result, m.end())
                if m2 is not None:
                    param = json.loads(m2.group(1))
                    end = m2.end()
            val = VAR_FUNCS[varlow](cfg, filepath, param)
        elif varlow in VAR_USER:
            val = VAR_USER[varlow]
        else:
            print('Warning: unknown variable {}'.format(var))
            val = '<unknown>'

        result = result[:start] + val + result[end:]
        m = regexvar.search(result, m.start())

    return result


def create_templates(cfg):
    for filepath in cfg.files:
        filepath = os.path.abspath(filepath)
        filename = os.path.basename(filepath)
        ext = os.path.splitext(filename)[1]
        if ext[0] == '.':
            ext = ext[1:]

        if ext not in cfg.map_ext:
            print("Warning: no template for extension .{}".format(ext))
            continue

        if not cfg.force and os.path.exists(filepath):
            print("Warning: {} file exists, skipping".format(filename))
            continue

        templ_name = cfg.map_ext[ext]
        templ_path = ''

        # find correct dir for the matching template file
        for templ_dir in cfg.search_dir:
            templ_dir = os.path.abspath(templ_dir)
            templ_path = os.path.join(templ_dir, templ_name)
            if os.path.exists(templ_path):
                break

        # check if we found a suitable template path
        if not os.path.exists(templ_path):
            print('Warning: no path found for {}'.format(templ_name))
            continue

        # read the content from the template file
        templ_content = ''
        with open(templ_path, 'r') as f:
            templ_content = f.read()

        # replace variables given in template
        templ_content = replace_vars(templ_content, cfg, filepath)

        # write the new file
        with open(filepath, 'w') as f:
            f.write(templ_content)

        print('[OK] {}'.format(filename))


if __name__ == '__main__':
    cfg = parse_arguments()
    create_templates(cfg)
